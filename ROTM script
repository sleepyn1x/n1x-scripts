local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
if not Rayfield then
    warn("Rayfield module failed to load.")
end

local Window = Rayfield:CreateWindow({
    Name = "sleepyn1x ROTM",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "ROTM Script",
    LoadingSubtitle = "by sleepyn1x",
    Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "Big Hub"
    },

    Discord = {
       Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },

    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Untitled",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
})

local PlayerTab = Window:CreateTab("Player", 4483362458) -- Title, Image

-- Toggle element to start/stop the autofarm
local Toggle = PlayerTab:CreateToggle({
    Name = "AutoFarm",
    CurrentValue = false,
    Flag = "FarmToggle",
    Callback = function(Value)
       -- Название целевой части
       local targetPartName = "MeshPart"
       local player = game.Players.LocalPlayer
       local character = player.Character or player.CharacterAdded:Wait()
       local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
       local isActivatingPrompt = false  
 
       -- Функция для телепортации и активации ProximityPrompt
       local function teleportAndActivatePrompt(targetPart)
          -- Телепортируем игрока к целевой части
          humanoidRootPart.CFrame = targetPart.CFrame
          
          -- Ищем ProximityPrompt в целевой части
          local proximityPrompt = targetPart:FindFirstChildOfClass("ProximityPrompt")
          if proximityPrompt and proximityPrompt.Enabled and not isActivatingPrompt then
             isActivatingPrompt = true  -- Флаг для предотвращения множественной активации
             
             -- Активируем ProximityPrompt
             fireproximityprompt(proximityPrompt)
 
             isActivatingPrompt = false
          else
             if not proximityPrompt then
                warn("ProximityPrompt не найден в " .. targetPart.Name)
             elseif not proximityPrompt.Enabled then
                warn("ProximityPrompt отключен в " .. targetPart.Name)
             end
          end
       end
 
       -- Функция для выполнения цикла AutoFarm
       task.spawn(function()
          while Value do
             -- Ищем целевую часть в Workspace.Debris
             local debris = workspace:FindFirstChild("Debris")
             if debris then
                local targetPart = debris:FindFirstChild(targetPartName)
                if targetPart then
                   teleportAndActivatePrompt(targetPart)
                else
                   warn("Целевая часть '" .. targetPartName .. "' не найдена в Workspace.Debris")
                end
             else
                warn("Debris не найден в Workspace")
             end
             wait(1) -- Задержка перед следующей итерацией
          end
       end)
    end,
 })
 

-- Slider for WalkSpeed
local WalkSpeedSlider = PlayerTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {10, 100},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 10,
    Flag = "Slider1",
    Callback = function(Value)
        -- Ожидаем, пока Humanoid будет доступен
        local humanoid = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
        humanoid.WalkSpeed = Value
    end,
})

-- Slider for JumpPower
local JumpPowerSlider = PlayerTab:CreateSlider({
    Name = "JumpPower",
    Range = {10, 500},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 10,
    Flag = "Slider2",
    Callback = function(Value)
        local humanoid = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
        humanoid.JumpPower = Value
    end,
})


local ToggleChests = PlayerTab:CreateToggle({
    Name = "Show Chest Lines & Boxes",
    CurrentValue = false,  
    Flag = "ChestLineBoxToggle",
    Callback = function(Value)
       local chestLine = nil
       local chestBox = nil
       local chestRunning = false

       -- Функция для создания линии и коробки к части
       local function createLineAndBoxToChest(chestPart)
          if chestLine then
             chestLine:Destroy()
          end
          if chestBox then
             chestBox:Destroy()
          end

          -- Создаем линию
          chestLine = Instance.new("Beam")
          chestLine.Parent = game.Workspace
          local attachment1 = Instance.new("Attachment", game.Players.LocalPlayer.Character.HumanoidRootPart)
          local attachment2 = Instance.new("Attachment", chestPart)
          attachment1.Position = Vector3.new(0, 1, 0)
          attachment2.Position = Vector3.new(0, 1, 0)
          chestLine.Attachment0 = attachment1
          chestLine.Attachment1 = attachment2
          chestLine.Color = ColorSequence.new(Color3.fromRGB(255, 105, 180))
          chestLine.Width0 = 0.2
          chestLine.Width1 = 0.2

          -- Создаем бокс вокруг Chest
          chestBox = Instance.new("BoxHandleAdornment")
          chestBox.Parent = chestPart
          chestBox.Size = chestPart.Size + Vector3.new(0.5, 0.5, 0.5)
          chestBox.Adornee = chestPart
          chestBox.Color3 = Color3.fromRGB(255, 105, 180)
          chestBox.Transparency = 0.5
          chestBox.ZIndex = 5
          chestBox.AlwaysOnTop = true
       end

       task.spawn(function()
          while true do
             if Value then
                if not chestRunning then
                   chestRunning = true

                   -- Проверяем, существует ли контейнер Debris
                   local debris = workspace:FindFirstChild("Debris")
                   if debris then
                      -- Перебираем все объекты типа MeshPart в Debris
                      for _, part in pairs(debris:GetChildren()) do
                         if part:IsA("MeshPart") then
                            -- Ищем Body внутри MeshPart, если он есть
                            local targetPart = part:FindFirstChild("Body")
                            if targetPart then
                               createLineAndBoxToChest(targetPart)
                            end
                         end
                      end
                   else
                      print("No Debris container found in workspace")  -- Для отладки
                   end

                   -- Периодически проверяем состояние
                   while Value do
                      -- Преобразуем старые линии и коробки
                      wait(1)
                   end
                   chestRunning = false
                end
             else
                -- Очистка
                if chestLine then
                   chestLine:Destroy()
                   chestLine = nil
                end
                if chestBox then
                   chestBox:Destroy()
                   chestBox = nil
                end
                break
             end
             wait(1)
          end
       end)
    end,
})


 

 local TogglePlayers = PlayerTab:CreateToggle({
    Name = "Show Player Lines & Names",
    CurrentValue = false,  
    Flag = "PlayerLineToggle",
    Callback = function(Value)
       local playerLines = {}
       local playerRunning = false
 

       local function createLineAndNameToPlayer(targetPlayer)
          local character = targetPlayer.Character
          if not character then return end
 

          local targetPart = character:WaitForChild("HumanoidRootPart")
          local line = Instance.new("Beam")
          line.Parent = game.Workspace
          local attachment1 = Instance.new("Attachment", game.Players.LocalPlayer.Character.HumanoidRootPart)
          local attachment2 = Instance.new("Attachment", targetPart)
          attachment1.Position = Vector3.new(0, 1, 0)
          attachment2.Position = Vector3.new(0, 1, 0)
          line.Attachment0 = attachment1
          line.Attachment1 = attachment2
          line.Color = ColorSequence.new(Color3.fromRGB(255, 165, 0))  -- Оранжевая линия
          line.Width0 = 0.2
          line.Width1 = 0.2
 
          -- Создаем BillboardGui для отображения никнейма с прозрачным фоном
          local billboard = Instance.new("BillboardGui")
          billboard.Parent = targetPart
          billboard.Adornee = targetPart
          billboard.Size = UDim2.new(0, 100, 0, 50)
          billboard.StudsOffset = Vector3.new(0, 3, 0)
          billboard.AlwaysOnTop = true  -- Ник всегда виден сквозь стены
 
          local textLabel = Instance.new("TextLabel")
          textLabel.Parent = billboard
          textLabel.Size = UDim2.new(1, 0, 1, 0)
          textLabel.Text = targetPlayer.Name
          textLabel.TextColor3 = Color3.fromRGB(255, 165, 0)  -- Оранжевый цвет
          textLabel.TextStrokeTransparency = 0.5
          textLabel.TextSize = 16
          textLabel.BackgroundTransparency = 1  -- Прозрачный фон
 
          -- Сохраняем линию и BillboardGui
          table.insert(playerLines, {line, billboard})
       end
 
       -- Асинхронное обновление
       task.spawn(function()
          while true do
             if Value then  -- Если тумблер включен
                if not playerRunning then
                   playerRunning = true
                   for _, targetPlayer in pairs(game.Players:GetPlayers()) do
                      if targetPlayer ~= game.Players.LocalPlayer then
                         createLineAndNameToPlayer(targetPlayer)
                      end
                   end
 
                   while Value do
                      wait(1)  -- Проверяем раз в секунду
                   end
                   playerRunning = false
                end
             else
                -- Когда тумблер выключен, удаляем все линии и BillboardGui
                for _, data in ipairs(playerLines) do
                   data[1]:Destroy()  -- Линия
                   data[2]:Destroy()  -- Никнейм
                end
                playerLines = {}
                break  -- Выход из асинхронной функции, чтобы больше не выполнять код
             end
             wait(1)  -- Пауза между итерациями
          end
       end)
    end,
 })
 
 local PlayerTab = Window:CreateTab("Target")

 local TweenService = game:GetService("TweenService")
local targetPlayerName = ""
local previousPosition = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart").CFrame or CFrame.new(0, 0, 0)

local Input = PlayerTab:CreateInput({
    Name = "Target Player Name",
    CurrentValue = "",
    PlaceholderText = "Enter target player's name",
    RemoveTextAfterFocusLost = false,
    Flag = "TargetNameInput",
    Callback = function(Text)
        targetPlayerName = Text
        print("Target player set to: " .. targetPlayerName)
    end,
})

local AutoClickToggle = PlayerTab:CreateToggle({
   Name = "Auto Clicker",
   CurrentValue = false,
   Flag = "AutoClickToggle",
   Callback = function(Value)
       getgenv().AutoClick = Value
       task.spawn(function()
           while getgenv().AutoClick do
               mouse1click()
               wait(0.05) -- Скорость кликов
           end
       end)
   end,
})


local AutoAimToggle = PlayerTab:CreateToggle({
   Name = "Auto Aim",
   CurrentValue = false,
   Flag = "AutoAimToggle",
   Callback = function(Value)
       getgenv().AutoAim = Value
       task.spawn(function()
           while getgenv().AutoAim do
               local targetPlayer = game.Players:FindFirstChild(targetPlayerName)
               if targetPlayer and targetPlayer.Character then
                   local targetPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                   if targetPart then
                       local camera = workspace.CurrentCamera
                       local direction = (targetPart.Position - camera.CFrame.Position).unit
                       local newCFrame = CFrame.lookAt(camera.CFrame.Position, camera.CFrame.Position + direction)
                       camera.CFrame = newCFrame
                   end
               end
               wait(0.02) -- Плавность авто-аима
           end
       end)
   end,
})


local distanceAroundTarget = 10  
local stayDurationNearTarget = 3  
local backDuration = 2  

local DistanceSlider = PlayerTab:CreateSlider({
    Name = "Distance Around Target",
    Range = {5, 50},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = distanceAroundTarget,
    Flag = "DistanceSlider",
    Callback = function(Value)
        distanceAroundTarget = Value
        print("Distance set to: " .. distanceAroundTarget)
    end,
})

-- Исправим работу слайдера StayTimeSlider
local StayTimeSlider = PlayerTab:CreateSlider({
    Name = "Stay Duration Near Target",
    Range = {1, 10},
    Increment = 1,
    Suffix = "Seconds",
    CurrentValue = stayDurationNearTarget,
    Flag = "StayTimeSlider",
    Callback = function(Value)
        stayDurationNearTarget = Value
        print("Stay duration set to: " .. stayDurationNearTarget)
    end,
})

-- Исправим работу слайдера BackTimeSlider
local BackTimeSlider = PlayerTab:CreateSlider({
    Name = "Back Duration After Move",
    Range = {1, 10},
    Increment = 1,
    Suffix = "Seconds",
    CurrentValue = backDuration,
    Flag = "BackTimeSlider",
    Callback = function(Value)
        backDuration = Value
        print("Back duration set to: " .. backDuration)
    end,
})

local startMoving = false

local ToggleMove = PlayerTab:CreateToggle({
    Name = "Start Moving to Target",
    CurrentValue = false,
    Flag = "MoveToggle",
    Callback = function(Value)
        if Value then
            startMoving = true
            print("Movement started")

            task.spawn(function()
                while startMoving do
                    local targetPlayer = game.Players:FindFirstChild(targetPlayerName)
                    if targetPlayer and targetPlayer.Character then
                        local targetPosition = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if targetPosition then
                            local humanoidRootPart = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                            previousPosition = humanoidRootPart.CFrame

                            -- Цикличное движение вокруг цели с случайными точками
                            local angle = math.random() * 2 * math.pi
                            local xOffset = math.cos(angle) * distanceAroundTarget
                            local zOffset = math.sin(angle) * distanceAroundTarget
                            local movePosition = targetPosition.CFrame * CFrame.new(xOffset, 10, zOffset)  -- Добавляем 10 единиц по оси Y

                            -- Моментальное перемещение
                            humanoidRootPart.CFrame = movePosition
                            print("Moved to: " .. tostring(movePosition))

                            -- Плавное следование за целью с ускорением
                            local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
                            local lastPosition = targetPosition.Position

                            -- Следуем за таргетом
                            local startTime = tick()
                            while startMoving and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
                                local targetRootPart = targetPlayer.Character.HumanoidRootPart
                                local targetPos = targetRootPart.Position
                                local moveDistance = (targetPos - lastPosition).Magnitude

                                if moveDistance > 0 then
                                    local direction = (targetPos - humanoidRootPart.Position).unit
                                    local newTargetPos = targetPos + direction * distanceAroundTarget
                                    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Linear)  -- Уменьшаем длительность для ускоренного движения
                                    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = CFrame.new(newTargetPos.X, newTargetPos.Y + 10, newTargetPos.Z)})
                                    tween:Play()
                                    tween.Completed:Wait()
                                end

                                lastPosition = targetPos
                                -- Ожидание перед обновлением позиции
                                wait(0.1)
                                
                                -- Прерывание по времени нахождения рядом
                                if tick() - startTime > stayDurationNearTarget then
                                    break
                                end
                            end

                            -- После завершения следования, возвращаем на исходную позицию
                            humanoidRootPart.CFrame = previousPosition
                            print("Returned to previous position: " .. tostring(previousPosition))

                            -- Ожидание перед следующей итерацией
                            wait(backDuration)
                        else
                            warn("Target's HumanoidRootPart not found!")
                        end
                    else
                        warn("Target player not found or missing character!")
                    end
                end
            end)
        else
            startMoving = false
            print("Movement stopped")
        end
    end,
})

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    previousPosition = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart").CFrame or CFrame.new(0, 0, 0)
    print("Player position saved: " .. tostring(previousPosition))
end)
